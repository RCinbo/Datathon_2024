---
title: "Analysis of interventions"
author: "Ra√Øsa Carmen"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(rprojroot)
library(tidyverse)
library(arrow)
library(plotly)
library(tidygeocoder) # to go from address to coordinates
library(furrr) # for parallel geocoding
library(sf)
library(leaflet)
library(git2rdata)
library(patchwork)
library(viridis)
library(units)
datafolder <- find_root_file("Data",
                             criterion = has_file("Datathon_2024.Rproj"))
interventions1 <- read_parquet(file = paste0(datafolder,
                                             "/interventions1.parquet"))
interventions2 <- read_parquet(file = paste0(datafolder,
                                             "/interventions2.parquet"))
interventions3 <- read_parquet(file = paste0(datafolder,
                                             "/interventions3.parquet"))
interventions <- rbind(interventions1, interventions2, interventions3)
rm(interventions1, interventions2, interventions3)
interventions_permanence_geodata <-
  read_vc(file = "interventions_permanence_geodata",
          root = datafolder)
#remove spaces form the column names:
colnames(interventions) <- str_replace(colnames(interventions), " ", "_")

# clean up the time stamps; I cannot get the T0 and T1 format to work.
interventions <- interventions %>%
  mutate(T0 = as.POSIXct(T0, format = "%d%b%y:%H:%M:%OS"),
         T1 = as.POSIXct(T1, format = "%d%b%y:%H:%M:%OS"),
         T1confirmed = as.POSIXct(T1confirmed, format = "%Y-%m-%d %H:%M:%OS"),
         T2 = as.POSIXct(T2, format = "%Y-%m-%d %H:%M:%OS"),
         T3 = as.POSIXct(T3, format = "%Y-%m-%d %H:%M:%OS"),
         T4 = as.POSIXct(T4, format = "%Y-%m-%d %H:%M:%OS"),
         T5 = as.POSIXct(T5, format = "%Y-%m-%d %H:%M:%OS"),
         T6 = as.POSIXct(T6, format = "%Y-%m-%d %H:%M:%OS"),
         T7 = as.POSIXct(T7, format = "%Y-%m-%d %H:%M:%OS"))
interventions <- interventions %>%
  mutate(time_to_arrive = ifelse(!is.na(T3),
                                 difftime(T3, T0, units = "mins"),
                                 NA))
```

# General overview

Each of the three intervention files have the same number of observations and the same columns; we row bind all three files to obtain one R object with interventions.

```{r cars}
glimpse(interventions)
```


There are `r length(unique(interventions$Vector_type))` different possible vectors; `r paste(sort(unique(interventions$Vector_type)), collapse = ", " )`. The vast majority are either regular ambulance, MUG of PIT. An ambulance typically has two ambulance operators which are typically not nurses or doctors. These operators cannot administer medications but typically can use and AED or help the patients with oxygen for breathing. A PIT (Pre-hospital Intervention Team) has one a ambulance operator and a nurse that obtained special training. The nurse may administer medications, take an ECG or blood. In a MUG, there is an emergency doctor and a nurse that received additional training. The nurse typically drives the car (often an SUV).

```{r ventor_types, echo = FALSE}
p <- interventions %>%
  group_by(Vector_type) %>%
  summarize(nb_interventions = n()) %>%
  mutate(Vector_type = paste0(Vector_type, " (", nb_interventions, ")")) %>%
  ggplot(aes(y = Vector_type, x = nb_interventions)) +
  geom_bar(stat = "identity")
ggplotly(p)
```

# Permanence

I hypothesize that the permanence indicates the location of the "vector" (PIT/MUG/Ambulance).
Latitude and longitude are missing in `r round(100*sum(is.na(interventions$Longitude_permanence)) / nrow(interventions), 2)` % of the interventions while the postal code is missing in only `r round(100*sum(is.na(interventions$PostalCode_permanence)) / nrow(interventions), 2)`% of the interventions. No coordinate system is specified for the longitude and latitude. The range of longitude (`r interventions %>% filter(!is.na(Longitude_permanence)) %>% dplyr::pull(Longitude_permanence) %>% min()` to `r interventions %>% filter(!is.na(Longitude_permanence)) %>% dplyr::pull(Longitude_permanence) %>% max()`) or latitude (`r interventions %>% filter(!is.na(Latitude_permanence)) %>% dplyr::pull(Latitude_permanence) %>% min()` to `r interventions %>% filter(!is.na(Latitude_permanence)) %>% dplyr::pull(Latitude_permanence) %>% max()`) does not match with either WGS84, Lambert72, or Lambert2008 coordinate bounds (these are probably the most often used coordinate systems for Belgium). We therefor use the tidygeocoder package to obtain the coordinates of the address. 

The figure below shows that this package works well (click on the markers to see the original address) although the coordinates are not found for all addresses (there are some NAs).

```{r permanence_adress_to_coord, echo=FALSE}
interventions <- interventions %>%
  mutate(full_address_permanence = paste(StreetName_permanence,
                              HouseNumber_permanence,
                              as.character(PostalCode_permanence),
                              CityName_permanence),
         full_address_permanence = str_remove_all(full_address_permanence,
                                       regex("NA", ignore_case = FALSE))) %>%
  left_join(interventions_permanence_geodata,
            by = join_by(full_address_permanence == address))
#check whether this can be right
scaled_down_interventions <- interventions %>%
  filter(!is.na(longitude_permanence)) %>%
  group_by(full_address_permanence, Vector_type) %>%
  slice(1)
colorpal <- colorFactor(palette = 'RdYlGn',
                        scaled_down_interventions$Vector_type)

scaled_down_interventions %>%
  st_as_sf(coords = c("longitude_permanence", "latitude_permanence"),
           crs = "EPGS:4326") %>%
  leaflet() %>%
  addTiles() %>%
  addCircleMarkers(color = ~colorpal(Vector_type),
             popup = scaled_down_interventions %>%
               dplyr::pull(full_address_permanence)) %>%
  addLegend('bottomright', pal = colorpal,
            values = scaled_down_interventions$Vector_type,
            title = 'Vector_Type',
            opacity = 1)
```
However, obtaining the geolocation is quite slow. It takes about 500 seconds to obtain 1000 geolocations in parallel (7 parallel cores). Since there are only `r nrow(interventions_permanence_geodata)` unique permanence addresses, it was still feasible to obtain these. It should be noted that `r sum(is.na(interventions_permanence_geodata$latitude_permanence))` (`r round(sum(is.na(interventions_permanence_geodata$latitude_permanence))/nrow(interventions_permanence_geodata)*100,2)`%) geolocations were not found using the *tidygeocoder* package.

The coordinates of the tidygeocoder package and the specified seem to match quite well, except for a couple of obvious mistakes. The figure below shows the logitude and latitude according to tidygeocoder and according to the raw data. The red lines show the WGS84 bounds for Belgium. 
Most nonsensical raw longitude/latitude data points seem to be on a straight. We can hypothesize that these numbers should in fact be 10 or 100 times smaller.

```{r lonlat-raw-vs-tidygeocoder, echo=FALSE, warning = FALSE}
p_lon <- interventions %>%
  filter(!is.na(longitude_permanence)) %>%
  group_by(full_address_permanence, Vector_type) %>%
  slice(1) %>%
  ggplot(aes(x = longitude_permanence, y = Longitude_permanence)) +
  geom_point(alpha = 0.4) +
  xlab("tidygeocoder longitude") +
  ylab("raw longitude") +
  geom_vline(xintercept = c(2.5, 6.4), color = "red") +
  geom_hline(yintercept = c(2.5, 6.4), color = "red")
p_lat <- interventions %>%
  filter(!is.na(longitude_permanence)) %>%
  group_by(full_address_permanence, Vector_type) %>%
  slice(1) %>%
  ggplot(aes(x = latitude_permanence, y = Latitude_permanence)) +
  geom_point(alpha = 0.4) +
  xlab("tidygeocoder latitude") +
  ylab("raw latitude") +
  geom_vline(xintercept = c(49.5, 51.51), color = "red") +
  geom_hline(yintercept = c(49.5, 51.51), color = "red")

p_lon + p_lat
```

Indeed, if we correct the raw data by dividing the lon/lat by either 10 or 100 (depending on the value), all permanence locations lie within the red boundaries and are approximately the same as the tidygeocode locations (see figure below).

```{r corrected_lonlat, echo=FALSE, warning = FALSE}
interventions <- interventions %>%
  mutate(Longitude_permanence_corrected =
           ifelse(Longitude_permanence < 6.4,
                  Longitude_permanence,
                  ifelse(Longitude_permanence < 64,
                         Longitude_permanence/10,
                         Longitude_permanence/100)),
         Latitude_permanence_corrected =
           ifelse(Latitude_permanence < 51.51,
                  Latitude_permanence,
                  Latitude_permanence/10))
p_lon <- interventions %>%
  filter(!is.na(longitude_permanence)) %>%
  group_by(full_address_permanence, Vector_type) %>%
  slice(1) %>%
  ggplot(aes(x = longitude_permanence, y = Longitude_permanence_corrected)) +
  geom_point(alpha = 0.4) +
  xlab("tidygeocoder longitude") +
  ylab("corrected raw longitude") +
  geom_vline(xintercept = c(2.5, 6.4), color = "red") +
  geom_hline(yintercept = c(2.5, 6.4), color = "red")
p_lat <- interventions %>%
  filter(!is.na(longitude_permanence)) %>%
  group_by(full_address_permanence, Vector_type) %>%
  slice(1) %>%
  ggplot(aes(x = latitude_permanence, y = Latitude_permanence_corrected)) +
  geom_point(alpha = 0.4) +
  xlab("tidygeocoder latitude") +
  ylab("corrected raw latitude") +
  geom_vline(xintercept = c(49.5, 51.51), color = "red") +
  geom_hline(yintercept = c(49.5, 51.51), color = "red")

p_lon + p_lat
```


# Intervention
Similar to the permanence locations, we see that the longitude and latitude contain some nonsensical values. We correct those values accordingly.

```{r raw-intervention-location, echo=FALSE, fig.cap="A random sample of 5000 intervention locations with the raw, uncorrected longitude and latitude. The red lines show the bounding box of Belgium for the WGS84 coordinate system."}
interventions %>%
  group_by(Longitude_intervention, Latitude_intervention) %>%
  slice(1) %>% #remove duplicates
  ungroup() %>%
  slice_sample(n = 5000) %>% # don't keep all records because that makes the figure slow
  ggplot(aes(x = Longitude_intervention, y = Latitude_intervention)) +
  geom_point(alpha = 0.2) +
  geom_hline(yintercept = c(49.5, 51.51), color = "red") +
  geom_vline(xintercept = c(2.5, 6.4), color = "red")
```

```{r corrected-intervention-location, echo=FALSE, fig.cap="A random sample of 5000 intervention locations with corrected longitude and latitude. The red lines show the bounding box of Belgium for the WGS84 coordinate system."}
interventions <- interventions %>%
  mutate(Longitude_intervention =
           ifelse(Longitude_intervention < 2.5,
                  NA,
                  ifelse(Longitude_intervention < 6.4,
                         Longitude_intervention,
                         ifelse(Longitude_intervention < 64,
                                Longitude_intervention/10,
                                Longitude_intervention/100))),
         Latitude_intervention =
           ifelse(Latitude_intervention < 49.5,
                  NA,
                  ifelse(Latitude_intervention < 51.51,
                         Latitude_intervention,
                         Latitude_intervention/10)))
interventions %>%
  group_by(Longitude_intervention, Latitude_intervention) %>%
  slice(1) %>% #remove duplicates
  ungroup() %>%
  slice_sample(n = 5000) %>% # don't keep all records because that makes the figure slow
  ggplot(aes(x = Longitude_intervention, y = Latitude_intervention)) +
  geom_point(alpha = 0.2) +
  geom_hline(yintercept = c(49.5, 51.51), color = "red") +
  geom_vline(xintercept = c(2.5, 6.4), color = "red") +
  xlab("corrected longitude") +
  ylab("corrected latitude")
```

## Density of interventions in Belgium

```{r density-interventions-data, echo=FALSE, eval = !file.exists(paste0(datafolder, "/intervention_honeycomb.Rdata"))}
#tutorial https://urbandatapalette.com/post/2021-08-tessellation-sf/
interventions_sf <- interventions %>%
  filter(!is.na(Latitude_intervention) & !is.na(Longitude_intervention)) %>%
  st_as_sf(coords = c("Longitude_intervention", "Latitude_intervention"),
           crs = 4326)
area_honeycomb_grid <- st_make_grid(interventions_sf, square = FALSE,
                                   what = "polygons",
                                   n = 50)
# To sf and add grid ID
honeycomb_grid_sf = st_sf(area_honeycomb_grid) %>%
  # add grid ID
  mutate(grid_id = 1:length(lengths(area_honeycomb_grid)))

# count number of points in each grid
# https://gis.stackexchange.com/questions/323698/counting-points-in-polygons-with-sf-package-of-r
honeycomb_grid_sf$n_colli <-
  lengths(st_intersects(honeycomb_grid_sf, interventions_sf))

# remove grid without value of 0 (i.e. no points in side that grid)
honeycomb_count <- filter(honeycomb_grid_sf, n_colli > 0)
save(honeycomb_count, honeycomb_grid_sf, file = paste0(datafolder, "/intervention_honeycomb.Rdata"))
```
```{r density_interventions-plot, echo=FALSE, warning = FALSE}
library(tmap)
load(paste0(datafolder, "/intervention_honeycomb.Rdata"))
honeycomb_count <- honeycomb_count %>%
  mutate(log_n_colli = log(n_colli))
tm_shape(honeycomb_count) +
  tm_fill(
    col = "log_n_colli",
    palette = "Reds",
    style = "cont",
    title = "Number of interventions (log-scale)",
    id = "grid_id",
    showNA = FALSE,
    alpha = 0.6,
    popup.vars = c(
      "Number of interventions(log scale): " = "n_colli"
    ),
    popup.format = list(
      n_colli = list(format = "f", digits = 0)
    )
  ) +
  tm_borders(col = "grey40", lwd = 0.7)
```

## Time to arrive to the emergency

The time to arrive to an emergency site will likely depend on how urgent the triage nurse deems the intervention and the time of day (due to availability of ambulances, personnel, and supply and demand). The urgency can be derived from the column *EventLevel_Trip* which ranges from N0 (most urgent) to N8 (least urgent). `r round(100*mean(is.na(interventions$EventLevel_Trip)), 2)`% of interventions have a missing urgency level. By far most interventions have priority level *N5*. 
```{r, echo=FALSE}
interventions %>%
  filter(!is.na(EventLevel_Trip)) %>%
  ggplot(aes(x = EventLevel_Trip)) +
  geom_bar() +
  xlab("assigned priority level") +
  ylab("Number of interventions") 
```

```{r time-to-arrival-all, echo=FALSE, fig.cap = "Mean time from the initial call to the arrival at the interventins, depending on time-of-day and the emergency level (on the left). Urgency levels N7 and N8 were left out since we have too few (less than 100) interventions in those categories."}
p1 <- interventions %>%
  filter(!is.na(EventLevel_Trip) &
           !(EventLevel_Trip %in% c("N7A", "N7B", "N8")) &
           !is.na(time_to_arrive) &
           time_to_arrive > 0 &
           time_to_arrive < 100) %>%
  mutate(tod = hour(T0)) %>%
  group_by(tod, EventLevel_Trip) %>%
  summarize(mean_time_to_arrival = mean(time_to_arrive),
            sd_time_to_arrival = sd(time_to_arrive)) %>%
  mutate(lower = mean_time_to_arrival - 1.96 * sd_time_to_arrival,
         upper = mean_time_to_arrival + 1.96 * sd_time_to_arrival) %>%
  mutate(lower = ifelse(lower < 0, 0, lower)) %>%
  filter(mean_time_to_arrival < 25) %>% #remove one outlier
  ungroup() %>%
  ggplot(aes(x = tod, y = mean_time_to_arrival, color = EventLevel_Trip,
             group = EventLevel_Trip)) +
  geom_ribbon(aes(ymin = lower, ymax = upper, fill = EventLevel_Trip),
              alpha = 0.1, lty = 2) +
  geom_line() +
  ylab("Time to arrive to the intervention (minutes)") +
  xlab("Time of the day") +
  scale_fill_viridis(discrete = TRUE) +
  scale_color_viridis(discrete = TRUE) +
  theme(legend.position = "bottom")
p2 <- interventions %>%
  filter(!is.na(EventLevel_Trip) &
           !(EventLevel_Trip %in% c("N7A", "N7B", "N8")) &
           !is.na(time_to_arrive) &
           time_to_arrive > 0 &
           time_to_arrive < 100) %>%
  group_by(EventLevel_Trip) %>%
  summarize(mean_time_to_arrival = mean(time_to_arrive),
            sd_time_to_arrival = sd(time_to_arrive)) %>%
  mutate(lower = mean_time_to_arrival - 1.96 * sd_time_to_arrival,
         upper = mean_time_to_arrival + 1.96 * sd_time_to_arrival) %>%
  mutate(lower = ifelse(lower < 0, 0, lower)) %>%
  filter(mean_time_to_arrival < 25) %>% #remove one outlier
  ungroup() %>%
  ggplot(aes(x = EventLevel_Trip, y = mean_time_to_arrival,
             color = EventLevel_Trip)) +
  geom_point() +
  geom_errorbar(aes(ymin = lower, ymax = upper)) +
  scale_color_viridis(discrete = TRUE) +
  theme(legend.position = "bottom")
p1 + p2
```


# Cardiac arrests

Looking at the interventions data, it can be seen that the column *EventType_Trip*  indicates the reason of the trip i.e. the diagnosis of the patient at arrival of the EMS. Since AEDs are only recommended for cardiac arrests, we filter out the interventions which pertain to cardiac arrests. 

```{r cardiac-arrest-data, echo=TRUE}
cardiac_arrest <- interventions %>%
  filter(str_detect(EventType_Trip, regex("cardiac arrest",
                                          ignore_case = TRUE))) %>%
  mutate(death = 1*(!is.na(Abandon_reason) & Abandon_reason == "Overleden"))
```

The column *Abandon_reason* indicates why a transportation to the hospital may not have taken place. For `r sum(cardiac_arrest$death)` out of the `r nrow(cardiac_arrest)` cardiac arrests (`r round(100*mean(cardiac_arrest$death),2)`%), this column contains *"overleden"* (deceased) meaning the patient died before being transported. Since the overall survival rate for cardiac arrest outside of the hospital in Belgium is only about 5 to 10%, we can assume that many more succomb during or after transportation as well.

Most heart attacks are classified in the highest priority categories *N0* of *N1*

```{r cardiac-arrest-urgency, echo=TRUE, fig.cap = "classification of the urgency of a cardiac arrest intervention. One cardiac arrest did not get a priority level assigned.", echo=FALSE}
cardiac_arrest %>%
  filter(!is.na(EventLevel_Trip)) %>%
  ggplot(aes(x = EventLevel_Trip, fill = as.factor(death))) +
  geom_bar() +
  xlab("assigned priority level") +
  ylab("Number of cardiac arrest interventions") +
  scale_fill_discrete(name = "Death before transportation",
                      breaks = c("0", "1"),
                      labels = c("No", "Yes")) +
  theme(legend.position = "bottom")
```

## Distance to the closest AED

Next to the time to arrival, we also are interested in looking at whether the distance to the closest AED can reduce the probability for the patient to die before being transported.

```{r cardiacarrests-aed, echo=FALSE, fig.cap = "Cardiac arrests in red and AED locations in blue."}
aed_loc <- read_parquet(
  file = paste0(datafolder, "/aed_locations.parquet.gzip")) %>%
  mutate(address = paste(address, number, postal_code, municipality)) %>%
  mutate(address = str_remove_all(address, "NA"))
aed_geoloc <- read_vc(file = "aed_geodata", root = datafolder)
aed_loc <- aed_loc %>%
  left_join(aed_geoloc)

aed_loc_sf <- aed_loc %>%
  filter(!is.na(latitude) &
           latitude > 49.5 & latitude < 51.51 &
           longitude > 2.5& longitude < 6.4) %>%
  st_as_sf(coords = c('longitude', 'latitude'), crs = "EPGS:4326")
cardiac_arrest_sf <- cardiac_arrest %>%
  filter(!is.na(Latitude_intervention)&
           Latitude_intervention > 49.5 & Latitude_intervention < 51.51 &
           Longitude_intervention > 2.5 & Longitude_intervention < 6.4) %>%
  st_as_sf(coords = c('Longitude_intervention', 'Latitude_intervention'),
           crs = "EPGS:4326")
cardiac_arrest_sf <- cardiac_arrest_sf %>% sf::st_set_crs(4326)
aed_loc_sf <- aed_loc_sf %>% sf::st_set_crs(4326)
ggplot() +
  geom_sf(data = aed_loc_sf, color = "blue") +
  geom_sf(data = cardiac_arrest_sf, color = "red")
write_vc(aed_loc, file = "aed_locations", root = datafolder,
         sorting = "address")
```

Some geographical locations for both the AED machines and the cardiac arrests could not be reliably found. Finally, `r nrow(aed_loc_sf)` of the `r nrow(aed_loc)` AED machines and `r nrow(cardiac_arrest_sf)` of the `r nrow(cardiac_arrest)` remain in the final dataset. For each of the cardiac arrests, we determine which AED machine is closest to the intervention site and the distance between both (in meters).

```{r, echo=TRUE}
cardiac_arrest_sf_lambert <-  cardiac_arrest_sf %>%
  st_transform(crs = "EPSG:31370")
aed_loc_sf_lambert <- aed_loc_sf %>%
  st_transform(crs = "EPSG:31370")
#transform to lambert to get the distance in meters
idx_closest <- st_nearest_feature(cardiac_arrest_sf_lambert, aed_loc_sf_lambert)
distances <-
  sapply(X = seq_len(length(idx_closest)),
         FUN = function(x){
           a <- st_distance(cardiac_arrest_sf_lambert[x,],
                            aed_loc_sf_lambert[idx_closest[x],])
           return(drop_units(a))
           })
cardiac_arrest_sf$distance_closest_idx <- idx_closest
cardiac_arrest_sf$distance_closest_distance <- distances
cardiac_arrest <- cardiac_arrest %>%
  left_join(cardiac_arrest_sf %>%
              st_drop_geometry())
save(cardiac_arrest, file = paste0(datafolder, "/cardiac_arrest.Rdata"))
```

