---
title: "Analysis of interventions"
author: "Ra√Øsa Carmen"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(rprojroot)
library(tidyverse)
library(arrow)
library(plotly)
library(tidygeocoder) # to go from address to coordinates
library(furrr) # for parallel geocoding
library(sf)
library(leaflet)
library(git2rdata)
library(patchwork)
datafolder <- find_root_file("Data",
                             criterion = has_file("Datathon_2024.Rproj"))
interventions1 <- read_parquet(file = paste0(datafolder,
                                             "/interventions1.parquet"))
interventions2 <- read_parquet(file = paste0(datafolder,
                                             "/interventions2.parquet"))
interventions3 <- read_parquet(file = paste0(datafolder,
                                             "/interventions3.parquet"))
interventions <- rbind(interventions1, interventions2, interventions3)
rm(interventions1, interventions2, interventions3)
interventions_permanence_geodata <-
  read_vc(file = "interventions_permanence_geodata",
          root = datafolder)
#remove spaces form the column names:
colnames(interventions) <- str_replace(colnames(interventions), " ", "_")
```

# General overview

Each of the three intervention files have the same number of observations and the same columns; we row bind all three files to obtain one R object with interventions.

```{r cars}
glimpse(interventions)
```


There are `r length(unique(interventions$Vector_type))` different possible vectors; `r paste(sort(unique(interventions$Vector_type)), collapse = ", " )`. The vast majority are either regular ambulance, MUG of PIT. An ambulance typically has two ambulance operators which are typically not nurses or doctors. These operators cannot administer medications but typically can use and AED or help the patients with oxygen for breathing. A PIT (Pre-hospital Intervention Team) has one a ambulance operator and a nurse that obtained special training. The nurse may administer medications, take an ECG or blood. In a MUG, there is an emergency doctor and a nurse that received additional training. The nurse typically drives the car (often an SUV).

```{r ventor_types, echo = FALSE}
p <- interventions %>%
  group_by(Vector_type) %>%
  summarize(nb_interventions = n()) %>%
  mutate(Vector_type = paste0(Vector_type, " (", nb_interventions, ")")) %>%
  ggplot(aes(y = Vector_type, x = nb_interventions)) +
  geom_bar(stat = "identity")
ggplotly(p)
```

# Permanence

I hypothesize that the permanence indicates the location of the "vector" (PIT/MUG/Ambulance).
Latitude and longitude are missing in `r round(100*sum(is.na(interventions$Longitude_permanence)) / nrow(interventions), 2)` % of the interventions while the postal code is missing in only `r round(100*sum(is.na(interventions$PostalCode_permanence)) / nrow(interventions), 2)`% of the interventions. No coordinate system is specified for the longitude and latitude. The range of longitude (`r interventions %>% filter(!is.na(Longitude_permanence)) %>% dplyr::pull(Longitude_permanence) %>% min()` to `r interventions %>% filter(!is.na(Longitude_permanence)) %>% dplyr::pull(Longitude_permanence) %>% max()`) or latitude (`r interventions %>% filter(!is.na(Latitude_permanence)) %>% dplyr::pull(Latitude_permanence) %>% min()` to `r interventions %>% filter(!is.na(Latitude_permanence)) %>% dplyr::pull(Latitude_permanence) %>% max()`) does not match with either WGS84, Lambert72, or Lambert2008 coordinate bounds (these are probably the most often used coordinate systems for Belgium). We therefor use the tidygeocoder package to obtain the coordinates of the address. 

The figure below shows that this package works well (click on the markers to see the original address) although the coordinates are not found for all addresses (there are some NAs).

```{r permanence_adress_to_coord, echo=FALSE}
interventions <- interventions %>%
  mutate(full_address_permanence = paste(StreetName_permanence,
                              HouseNumber_permanence,
                              as.character(PostalCode_permanence),
                              CityName_permanence),
         full_address_permanence = str_remove_all(full_address_permanence,
                                       regex("NA", ignore_case = FALSE))) %>%
  left_join(interventions_permanence_geodata,
            by = join_by(full_address_permanence == address))
#check whether this can be right
scaled_down_interventions <- interventions %>%
  filter(!is.na(longitude_permanence)) %>%
  group_by(full_address_permanence, Vector_type) %>%
  slice(1)
colorpal <- colorFactor(palette = 'RdYlGn',
                        scaled_down_interventions$Vector_type)

scaled_down_interventions %>%
  st_as_sf(coords = c("longitude_permanence", "latitude_permanence"),
           crs = "EPGS:4326") %>%
  leaflet() %>%
  addTiles() %>%
  addCircleMarkers(color = ~colorpal(Vector_type),
             popup = scaled_down_interventions %>%
               dplyr::pull(full_address_permanence)) %>%
  addLegend('bottomright', pal = colorpal,
            values = scaled_down_interventions$Vector_type,
            title = 'Vector_Type',
            opacity = 1)
```
However, obtaining the geolocation is quite slow. It takes about 500 seconds to obtain 1000 geolocations in parallel (7 parallel cores). Since there are only `r nrow(interventions_permanence_geodata)` unique permanence addresses, it was still feasible to obtain these. It should be noted that `r sum(is.na(interventions_permanence_geodata$latitude_permanence))` (`r round(sum(is.na(interventions_permanence_geodata$latitude_permanence))/nrow(interventions_permanence_geodata)*100,2)`%) geolocations were not found using the *tidygeocoder* package.

The coordinates of the tidygeocoder package and the specified seem to match quite well, except for a couple of obvious mistakes. The figure below shows the logitude and latitude according to tidygeocoder and according to the raw data. The red lines show the WGS84 bounds for Belgium. 
Most nonsensical raw longitude/latitude data points seem to be on a straight. We can hypothesize that these numbers should in fact be 10 or 100 times smaller.

```{r lonlat-raw-vs-tidygeocoder, echo=FALSE, warning = FALSE}
p_lon <- interventions %>%
  filter(!is.na(longitude_permanence)) %>%
  group_by(full_address_permanence, Vector_type) %>%
  slice(1) %>%
  ggplot(aes(x = longitude_permanence, y = Longitude_permanence)) +
  geom_point(alpha = 0.4) +
  xlab("tidygeocoder longitude") +
  ylab("raw longitude") +
  geom_vline(xintercept = c(2.5, 6.4), color = "red") +
  geom_hline(yintercept = c(2.5, 6.4), color = "red")
p_lat <- interventions %>%
  filter(!is.na(longitude_permanence)) %>%
  group_by(full_address_permanence, Vector_type) %>%
  slice(1) %>%
  ggplot(aes(x = latitude_permanence, y = Latitude_permanence)) +
  geom_point(alpha = 0.4) +
  xlab("tidygeocoder latitude") +
  ylab("raw latitude") +
  geom_vline(xintercept = c(49.5, 51.51), color = "red") +
  geom_hline(yintercept = c(49.5, 51.51), color = "red")

p_lon + p_lat
```

Indeed, if we correct the raw data by dividing the lon/lat by either 10 or 100 (depending on the value), all permanence locations lie within the red boundaries and are approximately the same as the tidygeocode locations (see figure below).

```{r corrected_lonlat, echo=FALSE, warning = FALSE}
interventions <- interventions %>%
  mutate(Longitude_permanence_corrected =
           ifelse(Longitude_permanence < 6.4,
                  Longitude_permanence,
                  ifelse(Longitude_permanence < 64,
                         Longitude_permanence/10,
                         Longitude_permanence/100)),
         Latitude_permanence_corrected =
           ifelse(Latitude_permanence < 51.51,
                  Latitude_permanence,
                  Latitude_permanence/10))
p_lon <- interventions %>%
  filter(!is.na(longitude_permanence)) %>%
  group_by(full_address_permanence, Vector_type) %>%
  slice(1) %>%
  ggplot(aes(x = longitude_permanence, y = Longitude_permanence_corrected)) +
  geom_point(alpha = 0.4) +
  xlab("tidygeocoder longitude") +
  ylab("corrected raw longitude") +
  geom_vline(xintercept = c(2.5, 6.4), color = "red") +
  geom_hline(yintercept = c(2.5, 6.4), color = "red")
p_lat <- interventions %>%
  filter(!is.na(longitude_permanence)) %>%
  group_by(full_address_permanence, Vector_type) %>%
  slice(1) %>%
  ggplot(aes(x = latitude_permanence, y = Latitude_permanence_corrected)) +
  geom_point(alpha = 0.4) +
  xlab("tidygeocoder latitude") +
  ylab("corrected raw latitude") +
  geom_vline(xintercept = c(49.5, 51.51), color = "red") +
  geom_hline(yintercept = c(49.5, 51.51), color = "red")

p_lon + p_lat
```


# Intervention
Similar to the permanence locations, we see that the longitude and latitude contain some nonsensical values. We correct those values accordingly.

```{r raw-intervention-location, echo=FALSE, fig.cap="A random sample of 5000 intervention locations with the raw, uncorrected longitude and latitude. The red lines show the bounding box of Belgium for the WGS84 coordinate system."}
interventions %>%
  group_by(Longitude_intervention, Latitude_intervention) %>%
  slice(1) %>% #remove duplicates
  ungroup() %>%
  slice_sample(n = 5000) %>% # don't keep all records because that makes the figure slow
  ggplot(aes(x = Longitude_intervention, y = Latitude_intervention)) +
  geom_point(alpha = 0.2) +
  geom_hline(yintercept = c(49.5, 51.51), color = "red") +
  geom_vline(xintercept = c(2.5, 6.4), color = "red")
```

```{r corrected-intervention-location, echo=FALSE, fig.cap="A random sample of 5000 intervention locations with corrected longitude and latitude. The red lines show the bounding box of Belgium for the WGS84 coordinate system."}
interventions <- interventions %>%
  mutate(Longitude_intervention =
           ifelse(Longitude_intervention < 2.5,
                  NA,
                  ifelse(Longitude_intervention < 6.4,
                         Longitude_intervention,
                         ifelse(Longitude_intervention < 64,
                                Longitude_intervention/10,
                                Longitude_intervention/100))),
         Latitude_intervention =
           ifelse(Latitude_intervention < 49.5,
                  NA,
                  ifelse(Latitude_intervention < 51.51,
                         Latitude_intervention,
                         Latitude_intervention/10)))
interventions %>%
  group_by(Longitude_intervention, Latitude_intervention) %>%
  slice(1) %>% #remove duplicates
  ungroup() %>%
  slice_sample(n = 5000) %>% # don't keep all records because that makes the figure slow
  ggplot(aes(x = Longitude_intervention, y = Latitude_intervention)) +
  geom_point(alpha = 0.2) +
  geom_hline(yintercept = c(49.5, 51.51), color = "red") +
  geom_vline(xintercept = c(2.5, 6.4), color = "red") +
  xlab("corrected longitude") +
  ylab("corrected latitude")
```

## Density of interventions in Belgium

```{r density-interventions-data, echo=FALSE, eval = !file.exists(paste0(datafolder, "/intervention_honeycomb.Rdata"))}
#tutorial https://urbandatapalette.com/post/2021-08-tessellation-sf/
interventions_sf <- interventions %>%
  filter(!is.na(Latitude_intervention) & !is.na(Longitude_intervention)) %>%
  st_as_sf(coords = c("Longitude_intervention", "Latitude_intervention"),
           crs = 4326)
area_honeycomb_grid <- st_make_grid(interventions_sf, square = FALSE,
                                   what = "polygons",
                                   n = 50)
# To sf and add grid ID
honeycomb_grid_sf = st_sf(area_honeycomb_grid) %>%
  # add grid ID
  mutate(grid_id = 1:length(lengths(area_honeycomb_grid)))

# count number of points in each grid
# https://gis.stackexchange.com/questions/323698/counting-points-in-polygons-with-sf-package-of-r
honeycomb_grid_sf$n_colli <-
  lengths(st_intersects(honeycomb_grid_sf, interventions_sf))

# remove grid without value of 0 (i.e. no points in side that grid)
honeycomb_count <- filter(honeycomb_grid_sf, n_colli > 0)
save(honeycomb_count, honeycomb_grid_sf, file = paste0(datafolder, "/intervention_honeycomb.Rdata"))
```
```{r density_interventions-plot, echo=FALSE, warning = FALSE}
library(tmap)
load(paste0(datafolder, "/intervention_honeycomb.Rdata"))
honeycomb_count <- honeycomb_count %>%
  mutate(log_n_colli = log(n_colli))
tm_shape(honeycomb_count) +
  tm_fill(
    col = "log_n_colli",
    palette = "Reds",
    style = "cont",
    title = "Number of interventions (log-scale)",
    id = "grid_id",
    showNA = FALSE,
    alpha = 0.6,
    popup.vars = c(
      "Number of interventions(log scale): " = "n_colli"
    ),
    popup.format = list(
      n_colli = list(format = "f", digits = 0)
    )
  ) +
  tm_borders(col = "grey40", lwd = 0.7)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
